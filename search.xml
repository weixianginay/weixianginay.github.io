<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[工作中遇到的BUG和解决方案]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84BUG%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[记录一下自己遇到的各种有趣的BUG. idea部署项目，404date: 2018-06-22IDEA在拉取svn项目部署后，可以成功运行，debug模式下，可以进入controller。但在跳转页面的时候，报错404。解决：在 “Edit Configurations” 里面找到 “working directory” 选择 “$MODULE_DIR$” 即可。 ORA-01400: cannot insert NULL into (\”TEST\”.\”T_ORDER\”.\”FEE_TYPE\”)date: 2018-01-31本地开发环境，项目A HTTP调用项目B，项目B可以插入数据库并返回项目B结果。把项目的上线文档整理后，让运维发布到测试环境，数据报错，Cause: java.sql.SQLException: ORA-01400: cannot insert NULL into。一直纠结在是不是打包问题，oracle版本问题，始终无法解决。解决：查看上线文档中的sql，比对本地表结构，发现sql不一致！给的我建表sql有问题，修改后解决。 利用CMPP协议发送短信，长短信乱码，发送失败。date: 2018-01-24短信运营商提供两种HTTP和CMPP发送短信方式，HTTP比较常见，简单。CMPP是中移动的协议方案，通过socket链接发送数据，我的demo是分别启动两个线程，一个发送线程，一个接受线程，高并发下（测试群发50人，人均10条不同内容，在1s内执行完毕，后续短信均符合要求）完美运行。可是！非常奇怪的是，当发送长短信时，调用失败，对方技术告诉我是，乱码问题。解决：demo中提交短信内容，Msg_Fmt设置的(byte) 0x15改成 (byte) 0x08，并且content.getBytes(“UTF-16BE”)。1234567CMPP协议中，Msg_Fmt规定只能为以下值。0：ASCII串3：短信写卡操作4：二进制信息8：UCS2编码15：含GB汉字CMPP协议严格规定了通信参数长度及格式，我建议在demo的基础上微调，新手不要造轮子。 Oracle查询分页有重复数据date: 2017-11-26Oracle sql查询分页时，如果排序字段相同数据大于页数，第二页就会有重复现象解决：sql中，加入主键排序，可以避免此问题（因为主键不会有大量重复的情况，也可以选择一个相对唯一的字段排序） 获取完整SQL语句date: 2017-11-08维护两个项目，用的orm一个是hibernate1，一个是ibatis，控制台都不能完整sql，不方便单独运行sql。解决：从网址找的资料，发现p6spy.jar可以处理，从maven官网下载合适的jar包，和配置文件，项目的oracle.jdbc.driver.OracleDriver更换成p6spy的。源jar包的方法，会把所有的sql全部输出，控制台大量重复sql。可以更改jar包源码，去除重复sql输出。12345678910111213141516171819202122package com.p6spy.engine.logging.appender;public abstract class FormattedLogger &#123; protected String lastEntry; private String cache = &quot;&quot;; public FormattedLogger() &#123;&#125; public void logSQL(int connectionId, String now, long elapsed, String category, String prepared, String sql) &#123; if(&quot;resultset&quot;.equals(category) &amp;&amp; !this.cache.equals(prepared)) &#123; String logEntry = &quot;\n&quot; + prepared; this.cache = prepared; System.err.println(&quot;----sql----&quot;); this.logText(logEntry); &#125; &#125; public abstract void logText(String var1); public void setLastEntry(String inVar) &#123;this.lastEntry = inVar;&#125; public String getLastEntry() &#123;return this.lastEntry;&#125;&#125;]]></content>
      <tags>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC Date Bad request 解决办法]]></title>
    <url>%2F2016%2F12%2F05%2FSpringMVC-Date-Bad-request-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这段时间，在写一个简单的StringMVC中Controller 遇到一个这样的问题。Controller类参数对象中，有一个属性是Date格式的，前台传值时，总是报HTTP 400 的错。最后的解决思路是在spring-mvc.xml 中加入配置1234567891011121314&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;org.springframework.core.convert.support.StringToBooleanConverter&quot;&gt;&lt;/bean&gt; &lt;bean class=&quot;com.*.*.converters.StringToEnumConverterFactory&quot; /&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;formatters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;com.*.*.converters.DateFormatter&quot;&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 1234567891011121314151617 public class DateFormatter implements Formatter&lt;Date&gt; &#123; public String print(Date object, Locale locale) &#123; return null; &#125; public Date parse(String text, Locale locale) throws ParseException &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date date = null; try &#123; date = format.parse(text); &#125; catch (Exception e) &#123; format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); date = format.parse(text); &#125; return date; &#125; &#125; 问题解决。可以再加入一个 枚举转换123456789101112131415161718final class StringToEnumConverterFactory implements ConverterFactory&lt;String, Enum&gt; &#123; public &lt;T extends Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) &#123; return new StringToEnum(targetType); &#125; private class StringToEnum&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; &#123; private final Class&lt;T&gt; enumType; public StringToEnum(Class&lt;T&gt; enumType) &#123; this.enumType = enumType; &#125; public T convert(String source) &#123; if (source.length() == 0) &#123; // It&apos;s an empty enum identifier: reset the enum value to null. return null; &#125; return (T) Enum.valueOf(this.enumType, source.trim()); &#125; &#125; &#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC Controller异常拦截@ControllerAdvice]]></title>
    <url>%2F2016%2F12%2F02%2FSpringMVC-Controller%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA-ControllerAdvice%2F</url>
    <content type="text"><![CDATA[最近在维护一个模块的API时，发现Controller中，如果参数在某些情况下，解析会产生异常。一方面是代码考虑不周全，待完善。另一方面因为是API，只负责正确数据的处理，所以大部分异常都是参数没有按照正确的格式传入造成的。所以 @ControllerAdvice 可以很好的捕获前台层面的异常。1.创建一个java类，并加入注解。如下：12345678910111213141516171819202122import com.lwl.api.service.common.bean.ResultCode; import com.lwl.api.service.common.bean.ResultInfo; import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.ResponseStatus; import org.springframework.web.servlet.config.annotation.EnableWebMvc; @ControllerAdvice public class GlobalExceptionHandler &#123; @ResponseStatus(HttpStatus.BAD_REQUEST) @ResponseBody @ExceptionHandler(Exception.class) public ResultInfo signException(Exception ex) &#123; ResultInfo resultInfo=new ResultInfo(); resultInfo.setData(&quot;参数或格式错误&quot;); resultInfo.setResultCode(ResultCode.Exception); resultInfo.setMsg(&quot;异常信息：&quot;+ex.getMessage()); return resultInfo; &#125; &#125; 2.记得在XML文件里，扫描到该文件包12&lt;context:annotation-config/&gt; &lt;context:component-scan base-package=&quot;com.***.***&quot;/&gt; PS:如果以上代码，没有捕获成功。可以在 @ControllerAdvice 上面再加一个@EnableWebMvc 的注解。12@EnableWebMvc@ControllerAdvice —————20171208更新线————–最近的在更新一个SpringBoot项目，发现boot项目大量使用注解完成配置。这个项目也是API项目，但是返回值不太一样，都继承一个类，和之前的泛型类很不一样。就在这个方法上扩展了下。这是SpringBoot的配置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@ControllerAdvicepublic class GlobalExceptionHandler &#123; protected final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private RequestMappingHandlerMapping handlerMapping; @ResponseStatus(HttpStatus.BAD_REQUEST) @ResponseBody @ExceptionHandler(Exception.class) public ResultBase signException(HttpServletRequest request, Exception e) &#123; String resultMsg=&quot;操作异常：&quot;; Map map = this.handlerMapping.getHandlerMethods(); String path= request.getServletPath(); Iterator&lt;?&gt; iterator = map.entrySet().iterator(); boolean flag=true; while(iterator.hasNext()&amp;&amp;flag)&#123; Map.Entry entry = (Map.Entry) iterator.next(); RequestMappingInfo info= (RequestMappingInfo)entry.getKey(); Set&lt;String&gt; set= info.getPatternsCondition().getPatterns(); for(String c:set)&#123; if(path.equals(c))&#123; HandlerMethod handlerMethod=(HandlerMethod) entry.getValue(); Method method = handlerMethod.getMethod(); boolean isToken = method.isAnnotationPresent(ApiOperation.class); if (isToken)&#123; ApiOperation annotation = method.getAnnotation(ApiOperation.class); resultMsg=annotation.value()+&quot;失败：&quot;; &#125; String err= handlerMethod.getBean().toString()+&quot;.&quot;+method.getName()+&quot; error&quot;; logger.error(err, e); flag=false; &#125; &#125; &#125; ResultBase resultBase=new ResultBase(OperInfoEnum.oper_fail, resultMsg+e); return resultBase; &#125; @ResponseStatus(HttpStatus.BAD_REQUEST) @ResponseBody @ExceptionHandler(MissingServletRequestParameterException.class) public ResultBase signException(MissingServletRequestParameterException e) &#123; ResultBase resultBase=new ResultBase(OperInfoEnum.oper_null,&quot;参数为空：&quot;+e.getParameterName()); return resultBase; &#125;&#125; 主要是细分了异常类的处理，和从Spring中获取所有的Mapping定位到具体的Controller（这里暂时没找到直接定位的方法），反射拿到注解上的参数，更友好的提示。 参考资料： 《Spring3.2新注解@ControllerAdvice》 《使用spring MVC的@ControllerAdvice注解做Json的异常处理》 《@EnableWebMvc》]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
